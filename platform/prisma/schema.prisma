// Event Management Platform - Prisma Schema
// Database: PostgreSQL
// Generated: 2025-12-28

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USERS & AUTHENTICATION
// ============================================================================

/// User entity with deletion protection
///
/// NOTE: User deletion is protected by onDelete: Restrict on Room organizer relation.
/// Cannot hard delete a User if they created any Rooms (even soft-deleted rooms).
///
/// @example Correct deletion:
/// ```typescript
/// // 1. Transfer or soft delete user's rooms first
/// await prisma.room.updateMany({
///   where: { createdBy: 'usr_abc123' },
///   data: { deletedAt: new Date() },
/// });
///
/// // 2. Then soft delete the user
/// await prisma.user.update({
///   where: { id: 'usr_abc123' },
///   data: { deletedAt: new Date() },
/// });
/// ```
///
/// See: platform/prisma/MIGRATION_PLAN.md - Cascade Behavior section
model User {
  id     String  @id @default(cuid())
  email  String  @unique
  name   String?
  avatar String?

  // OAuth provider data
  provider      String    @default("google") // google, yandex, vk, email
  providerId    String? // External provider user ID
  emailVerified DateTime?

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete

  // Relations
  participations Participant[]
  createdRooms   Room[]        @relation("RoomOrganizer") // Room → User uses onDelete: Restrict (prevents hard delete if user created rooms)
  sessions       Session[]

  @@unique([provider, providerId])
  @@index([email])
  @@index([deletedAt])
  @@map("users")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  refreshToken String   @unique
  expiresAt    DateTime

  // Session metadata for security tracking
  deviceInfo String? // User agent or device description
  ipAddress  String? // IP address of session creation
  lastUsedAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([refreshToken])
  @@index([expiresAt])
  @@index([lastUsedAt]) // For cleaning up stale sessions
  @@map("sessions")
}

model TokenBlacklist {
  id String @id @default(cuid())

  // Store hash of revoked access token (not the token itself)
  tokenHash String   @unique
  expiresAt DateTime

  // Revocation metadata
  userId    String
  reason    String? // logout, security_breach, manual_revoke, etc.
  revokedAt DateTime @default(now())
  revokedBy String? // Admin ID if manually revoked

  @@index([tokenHash]) // Fast lookup for validation
  @@index([expiresAt]) // For automatic cleanup of expired entries
  @@index([userId]) // Track user's revoked tokens
  @@map("token_blacklist")
}

// ============================================================================
// APPLICATIONS
// ============================================================================

/// Application entity with deletion protection
///
/// NOTE: App deletion is protected by onDelete: Restrict on Room relation.
/// Cannot hard delete an App if any Rooms reference it (even soft-deleted rooms).
///
/// @example Correct deletion:
/// ```typescript
/// // 1. Soft delete all rooms first (or ensure no rooms exist)
/// await prisma.room.updateMany({
///   where: { appId: 'app_lottery_v1' },
///   data: { deletedAt: new Date() },
/// });
///
/// // 2. Then soft delete the app
/// await prisma.app.update({
///   where: { appId: 'app_lottery_v1' },
///   data: { deletedAt: new Date() },
/// });
/// ```
///
/// See: platform/prisma/MIGRATION_PLAN.md - Cascade Behavior section
model App {
  id        String @id @default(cuid())
  appId     String @unique // app_lottery_v1
  appSecret String @unique // sk_live_abc123...

  // Manifest versioning
  manifest        Json // Current manifest (JSON)
  manifestVersion String // Semantic version (e.g., "1.2.3")
  manifestHistory Json   @default("[]") // Array of previous manifest versions with metadata

  // Status
  isActive Boolean @default(true)

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete

  // Relations
  rooms Room[] // Room → App uses onDelete: Restrict (prevents hard delete if rooms exist)

  @@index([appId])
  @@index([isActive])
  @@index([deletedAt])
  @@index([manifestVersion]) // Query by specific manifest version
  @@map("apps")
}

// ============================================================================
// ROOMS & EVENTS
// ============================================================================

enum RoomStatus {
  DRAFT
  ACTIVE
  COMPLETED
  CANCELLED
}

model Room {
  id          String  @id @default(cuid())
  name        String
  description String?

  // Application integration
  appId              String
  appSettings        Json // Application-specific settings validated against app manifest
  appManifestVersion String // Manifest version used when room was created (locks room to specific schema)

  // Status & visibility
  status   RoomStatus @default(DRAFT)
  isPublic Boolean    @default(true)

  // Organizer
  createdBy String

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete

  // Relations
  app          App           @relation(fields: [appId], references: [appId], onDelete: Restrict)
  organizer    User          @relation("RoomOrganizer", fields: [createdBy], references: [id], onDelete: Restrict)
  participants Participant[]
  prizes       Prize[]
  winners      Winner[]

  @@index([appId])
  @@index([status])
  @@index([isPublic])
  @@index([createdBy])
  @@index([createdAt])
  @@index([deletedAt])
  @@index([appManifestVersion]) // Query rooms by manifest version
  @@index([status, isPublic, appId]) // Composite index for common queries
  @@index([appId, appManifestVersion]) // Query rooms by app and version
  @@map("rooms")
}

// ============================================================================
// PARTICIPANTS
// ============================================================================

enum ParticipantRole {
  ADMIN
  ORGANIZER
  MODERATOR
  PARTICIPANT
  VIEWER
}

model Participant {
  id     String          @id @default(cuid())
  userId String
  roomId String
  role   ParticipantRole @default(PARTICIPANT)

  // Application-specific metadata (e.g., ticketNumber, score, etc.)
  metadata Json?

  // Timestamps
  joinedAt  DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete (user left room)

  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  room    Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  winners Winner[]

  @@unique([userId, roomId]) // User can only join room once
  @@index([roomId])
  @@index([userId])
  @@index([role])
  @@index([deletedAt])
  @@index([roomId, role]) // Common query pattern
  @@map("participants")
}

// ============================================================================
// PRIZES
// ============================================================================

/// Prize entity with strict deletion policy
///
/// CRITICAL: Prize deletion must ONLY be performed via soft delete (deletedAt field).
/// Hard deletion will fail if any Winner records exist due to onDelete: Restrict.
///
/// @example Correct deletion (soft delete):
/// ```typescript
/// await prisma.prize.update({
///   where: { id: 'prize_xyz' },
///   data: { deletedAt: new Date() },
/// });
/// ```
///
/// @example Wrong deletion (hard delete - will fail if winners exist):
/// ```typescript
/// await prisma.prize.delete({
///   where: { id: 'prize_xyz' },
/// });
/// // Error: P2003 - Foreign key constraint failed (Winner → Prize Restrict)
/// ```
///
/// See: platform/prisma/QUERY_EXAMPLES.md - Prize Deletion section
/// See: platform/prisma/MIGRATION_PLAN.md - Prize Deletion Policy
model Prize {
  id          String  @id @default(cuid())
  roomId      String
  name        String
  description String?
  imageUrl    String?

  // Quantity tracking
  quantity          Int @default(1)
  quantityRemaining Int @default(1)

  // Application-specific metadata (e.g., value, sponsor, category)
  metadata Json?

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete - REQUIRED for Prize deletion

  // Relations
  room    Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  winners Winner[] // Winner → Prize uses onDelete: Restrict (prevents hard delete if winners exist)

  @@index([roomId])
  @@index([deletedAt])
  @@map("prizes")
}

// ============================================================================
// WINNERS
// ============================================================================

model Winner {
  id            String @id @default(cuid())
  roomId        String
  participantId String
  prizeId       String

  // Application-specific metadata (e.g., drawNumber, timestamp, algorithm)
  metadata Json?

  // Timestamps
  createdAt DateTime  @default(now())
  deletedAt DateTime? // Soft delete (winner revoked)

  // Relations
  room        Room        @relation(fields: [roomId], references: [id], onDelete: Cascade)
  participant Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  prize       Prize       @relation(fields: [prizeId], references: [id], onDelete: Restrict)

  @@index([roomId])
  @@index([participantId])
  @@index([prizeId])
  @@index([createdAt])
  @@index([deletedAt])
  @@index([roomId, prizeId]) // Common query pattern
  @@map("winners")
}

// ============================================================================
// BILLING & SUBSCRIPTIONS
// ============================================================================

// NOTE: Billing and subscription features will be implemented POST-MVP
// after the platform has been validated with real users.
// For MVP: All users have free access to all features.
